# 分布式系统期末复习资料

## 📝 文档说明
这份文档是为 **分布式系统** 课程准备的深度复习资料。内容经过精心整理，旨在帮助你快速掌握考试重点。

**文档组成部分：**
1.  **核心考点复盘**：提炼每章的理论精华，防漏网之鱼。
2.  **进阶选择题库**：针对易错点和细节概念的模拟题。
3.  **大题预测与解析**：包括 **计算题**（NTP、时间戳、环选举）、**证明题**（共识）和 **代码填空**（MapReduce）。
4.  **答案与深度解析**：每道题都附带了详细的逻辑推导。

## 🎯 官方考试范围

### 题型分布
*   **大题部分**：5道大题，每题10分，共50分
*   **选择题部分**：25道选择题，每题2分，共50分

### 重点大题分布
1.  **大题1 时间戳**：Lamport 时间戳 / 向量时间戳
2.  **大题2 多播**：FIFO / 因果 / 全序
3.  **大题3 共识**：侧重协议设计与分析、证明
4.  **大题4 代码填空**：Go 语言 MapReduce（会有详细语法提示）
5.  **大题5 云计算模型**：三种服务模型和部署模型

### 详细考点清单 & 黑名单
*   **Gossip 协议**：❌ 不考
*   **Raft 算法**：❌ 不考
*   **云计算基础**：❌ 不考（仅考云计算模型）
*   **副本**：幂等性、重试行为、写后读一致性、仲裁机制（$W+R>N$）、读时修复。
*   **一致性**：2PC（含容错能力）、ABD 协议（CAS）。
*   **共识**：共识 vs 原子提交、环选举协议（消息复杂度 $3N-1$ vs $2N$）、同步系统共识证明。
*   **弱一致性**：CAP 定理（必考）、CRDT（一道选择题）。
*   **Hadoop/GFS**：GFS 设计特点、MapReduce 代码填空。

## 📚 章节导航
*   **第一章：分布式系统概述** - 并发模型、RPC、可用性计算
*   **第二章：分布式系统模型** - 拜占庭问题、同步/异步系统
*   **第三章：时间与时钟** - NTP、物理时钟
*   **第四章：广播协议与逻辑时间戳** - Lamport/向量时钟、多播排序（FIFO/因果/全序）
*   **第五章：副本** - Quorum 仲裁、读写一致性
*   **第六章：一致性** - 2PC、线性一致性 (Linearizability)、ABD算法
*   **第七章：共识** - 环选举算法复杂度、共识理论证明
*   **第八章：最终一致性** - CAP 定理、CRDT
*   **第九章：Hadoop 与 MapReduce** - GFS 架构、MapReduce (Go语言)
*   **第十章：云计算模型** - IaaS/PaaS/SaaS、部署模型

---

### 第一章：分布式系统概述 (深度复习)

#### 核心考点复盘（防漏网之鱼）
1.  **并发模型对比**：
    *   **共享内存 (Shared Memory)**：所有 CPU 访问同一地址空间。难点在于锁、信号量。硬件故障通常导致全崩。
    *   **消息传递 (Message Passing)**：每个节点有独立内存，靠网络发消息。这是分布式系统的基础。
    *   *PPT细节*：NUMA (Non-Uniform Memory Access) 是共享内存的一种架构；分布式系统更像“货车运硬盘”的高延迟环境。
2.  **性能指标的辩证关系**：
    *   **高带宽 $\neq$ 低时延**：PPT 里的经典案例（货车拉硬盘），带宽极大（一次能拉很多数据），但时延极高（跑一趟要很久）。
    *   *考点*：Web 请求通常对时延敏感，而大数据备份对带宽敏感。
3.  **可用性数学题**：
    *   SLA (协议) vs SLO (目标)。
    *   记住数量级：3个9 (99.9%) $\approx$ 停机 8.8小时/年；5个9 (99.999%) $\approx$ 停机 5分钟/年。
4.  **RPC 的深度实现**：
    *   **存根 (Stub)**：Client Stub 负责把函数调用转换成消息（Marshal），Server Stub 负责拆包（Unmarshal）并调用本地函数。
    *   **参数传递的本质难点**：
        *   **指针问题**：分布式环境下，A 机器的内存地址在 B 机器上是无效的。
        *   **解决方案**：C 语言中常用 **Copy-restore (复制-还原)** 机制来模拟引用调用（Reference）。即：把数据拷过去，算完再拷回来覆盖。
    *   **数据异构**：Big Endian (SPARC/网络序) vs Little Endian (Intel x86)。RPC 必须处理字节序转换。

---

#### 第一章：进阶选择题库 (8道)

**1. [概念辨析] 关于分布式系统与共享内存系统的区别，下列哪项描述是**错误**的？**
A. 在共享内存系统中，操作系统通常负责进程间的通信同步（如锁、信号量）
B. 分布式系统中的“消息传递模型”天然隔离了内存，因此不存在竞态条件（Race Condition）
C. 共享内存系统在硬件故障发生时，通常会导致所有在该硬件上运行的线程停止
D. 分布式系统通过消息传递来协作，即便某个节点发生单点故障（Crash），其他节点仍可能继续运行

**2. [性能指标] PPT 中提到了“货车运送硬盘”的案例，该案例旨在说明分布式网络通信中的什么特性？**
A. 网络传输的不可靠性（丢包率高）
B. 高带宽并不等于低时延
C. 物理传输介质（如公路）比光纤网络更安全
D. 数据的吞吐量（Throughput）受限于硬盘读写速度

**3. [可用性计算] 某云服务商承诺其对象存储服务的可用性为 "Four nines" (99.99%)。根据 PPT 中的估算，这意味着该服务每年允许的不可用时间大约是多少？**
A. 3.7 天
B. 8.8 小时
C. 53 分钟
D. 5.3 分钟

**4. [RPC 原理] 在远程过程调用（RPC）的执行链条中，以下步骤的正确执行顺序是？**
① Client 进程调用 Client Stub
② Network 传输消息
③ Server Stub 解包参数 (Unmarshal)
④ Client Stub 打包参数 (Marshal)
⑤ Client OS 发送消息
A. ① -> ⑤ -> ④ -> ② -> ③
B. ① -> ④ -> ⑤ -> ② -> ③
C. ④ -> ① -> ⑤ -> ② -> ③
D. ① -> ④ -> ② -> ⑤ -> ③

**5. [RPC 参数传递] C 语言进行 RPC 调用时，如果函数参数包含指针（如 `read(fd, buf, nbytes)` 中的 `buf`），RPC 中间件通常采用什么机制来处理？**
A. 直接传递指针地址，依靠分布式共享内存技术访问
B. 引用调用（Call by Reference），服务器通过回调获取数据
C. 复制-还原（Copy-restore），将数据复制到消息中发送，返回时再将结果复制回原地址
D. 禁止传递指针类型的参数，只允许传递值类型（Call by Value）

**6. [RPC 数据表示] 当一个采用 Little Endian（小端序，如 Intel 处理器）的客户端向一个采用 Big Endian（大端序，如 SPARC 处理器）的服务器发起 RPC 调用时，下列哪项是必须完成的工作？**
A. 客户端必须先将数据转换为服务器的 Big Endian 格式再发送
B. 服务器必须将接收到的所有数据转换为 Little Endian 格式
C. 通信双方必须协商一种数据格式，或者由接收方根据元数据进行字节序转换
D. TCP/IP 协议会自动处理应用层数据的字节序转换，上层无需关心

**7. [容错概念] 关于 Failure（故障）和 Fault（错误/缺陷）的区别，以及单点故障（SPOF），下列说法符合 PPT 定义的是？**
A. Fault 是指整个系统停止工作，Failure 是指部分部件停止工作
B. 容错（Fault Tolerance）的目标是完全消除系统中的所有 Fault
C. 只要系统中有组件发生 Fault，整个系统就必然发生 Failure
D. 单点故障（SPOF）是指某个节点的故障会导致整个分布式系统的 Failure

**8. [透明性限制] RPC 的设计目标是实现“透明调用”，但在实际应用中很难做到完全透明。以下哪项**不是**导致 RPC 无法完全透明的原因？**
A. 远程调用可能发生网络分区或超时，而本地调用不会
B. 远程调用的时延比本地调用高几个数量级
C. 远程调用无法直接共享全局变量
D. 远程调用的函数名必须与本地函数名不同

---

### 第二章：分布式系统模型 (深度复习)

#### 核心考点复盘（防漏网之鱼）
1.  **不可靠的本质**：
    *   **两将军问题**：证明了在**不可靠链路**（丢包）下，无法达成 100% 确定的共识。
    *   **应用**：电商发货问题。现实中通过“退款机制”规避了数学上的无解，但核心逻辑依然是最终一致性。
2.  **拜占庭将军问题**：
    *   **场景**：链路可靠，但**节点**可能是坏人（叛徒）。
    *   **叛徒行为**：由于是“任意故障 (Arbitrary failures)”，叛徒可以发假消息、甚至给不同的人发不同的消息。
    *   **铁律**：容忍 $f$ 个拜占庭节点，需要总节点数 $N \ge 3f + 1$。
3.  **系统假设的三维模型**（做题时必须看清题目假设）：
    *   **网络**：
        *   **Fair-loss**（公平丢包）：消息丢了没关系，只要我一直重传，总有一次能到。（这是构建可靠传输的基础）。
    *   **节点**：
        *   **Crash-stop**：死得干脆，死了就不说话。
        *   **Crash-recovery**：会重启，重启后内存丢了，硬盘还在。
        *   **Byzantine**：最坏情况，不仅不干活，还捣乱。
    *   **时间**：
        *   **Synchronous (同步)**：不仅网络延迟有上限，**节点处理速度**也有上限。这是最理想的模型。
        *   **Asynchronous (异步)**：**没有任何时间保证**。可能会延迟 1 毫秒，也可能延迟 100 年。
4.  **故障检测 (Failure Detector) 的悖论**：
    *   在**异步系统**中，你永远无法区分“节点崩溃”和“网络由于拥塞变慢了”。
    *   因此，异步系统中不存在**完美故障检测器 (Perfect Failure Detector)**。
    *   *PPT细节*：实践中会导致“虚假超时 (Spurious timeouts)”。

---

#### 第二章：进阶选择题库 (8道)

**9. [经典问题] 关于“两将军问题”和“拜占庭将军问题”的对比，以下描述准确的是？**
A. 两将军问题假设信道是可靠的，而拜占庭将军问题假设信道是不可靠的
B. 两将军问题可以通过引入三次握手协议完美解决
C. 拜占庭将军问题主要解决的是节点存在恶意行为（如篡改消息）时的共识问题
D. 如果没有叛徒，仅仅是消息丢失，那么拜占庭将军问题的算法（3f+1）也能解决消息丢失问题

**10. [拜占庭容错] 假设一个分布式系统需要使用拜占庭容错算法。如果你预计系统中最多可能有 2 个节点发生恶意篡改数据的行为，那么你的系统集群至少需要包含多少个节点？**
A. 5 个
B. 6 个
C. 7 个
D. 9 个

**11. [网络模型] PPT 中提到了 "Fair-loss"（公平丢包）链路模型。这个模型的含义是？**
A. 链路会随机丢包，且丢包的概率是均匀分布的
B. 如果发送方无限次地重复发送一条消息，接收方最终一定会收到该消息
C. 链路保证不丢包，但可能会乱序
D. 消息要么全部丢失，要么全部送达，不会出现部分送达的情况

**12. [节点故障模型] 在设计分布式算法时，通常认为哪种故障模型是最容易处理的（即对算法设计者最友好）？**
A. Byzantine (拜占庭故障)
B. Crash-recovery (崩溃-恢复)
C. Crash-stop (崩溃-停止)
D. Arbitrary failure (任意故障)

**13. [时间模型] 在“同步系统 (Synchronous System)”的定义中，下列哪项假设是**必须**的？**
A. 系统中所有节点的时钟必须是物理上完全一致的
B. 消息传递的延迟存在一个已知的上界（Max Delay）
C. 节点处理消息的速度可以无限快
D. 网络带宽必须是无限的

**14. [异步系统困境] 在一个完全“异步 (Asynchronous)”的分布式系统中，以下哪项操作是理论上**不可能**完美实现的？**
A. 消息的可靠投递（通过重传）
B. 区分一个节点是“崩溃了”还是“响应非常慢”
C. 保证消息的因果顺序
D. 存储数据到磁盘

**15. [实践中的同步] PPT 指出，虽然我们常假设网络是稳定的，但在实践中经常违反“同步”假设。以下哪项**不是**导致现实系统中出现不可预测延迟（违反同步假设）的常见原因？**
A. Java 等语言的垃圾回收（Garbage Collection）导致的 "Stop-the-world"
B. 操作系统进行内存交换（Swap）或页面抖动（Thrashing）
C. 网络交换机的缓冲区溢出导致的排队等待
D. 这里的 CPU 时钟频率是固定的（如 3.0GHz）

**16. [故障检测器] 关于“最终完美故障检测器 (Eventually Perfect Failure Detector)”，下列说法正确的是？**
A. 它从一开始就能准确无误地判断节点是否崩溃
B. 它只适用于完全同步的系统
C. 它允许在一段时间内出现误判（虚假超时），但最终会修正并给出正确判断
D. 它要求节点崩溃后必须立刻重启（Crash-recovery）

---

### ✅ 答案与深度解析

#### 第一章解析
1.  **B**。**错在“不存在竞态条件”**。虽然内存隔离了，但在分布式系统中，多个节点并发操作同一份数据（如数据库）或争抢资源时，依然存在严重的竞态条件（这也是为什么需要大题考点里的“共识”和“互斥”）。
2.  **B**。**高带宽 $\neq$ 低时延**。货车一次拉 100TB（高带宽），但开过去要 24 小时（高时延）。
3.  **C**。**53分钟**。
    *   2个9 (99%) = 3.7天
    *   3个9 (99.9%) = 8.8小时
    *   4个9 (99.99%) = 53分钟 (8.8小时除以10)
    *   5个9 (99.999%) = 5.3分钟
4.  **B**。**RPC 流程**：调用(1) -> 存根打包(4) -> OS发送(5) -> 网络(2) -> 存根解包(3)。
5.  **C**。**Copy-restore**。指针在远程无效，必须把指针指向的数据拷贝过去（Copy），处理完再拷回来覆盖（Restore）。
6.  **C**。**数据格式转换**。通常的做是：要么转换成标准网络序（Big Endian），要么发送方在消息里标记“我是Little Endian”，接收方看着办。不能指望 TCP 自动处理应用层数据的格式。
7.  **D**。**SPOF 定义**。A 错，PPT P41 定义 Failure 是整个系统挂，Fault 是部分部件挂。B 错，容错的目标是**带着 Fault 继续运行**，而不是消除 Fault。
8.  **D**。**透明性**。函数名是可以一样的，存根会处理映射。ABC 都是 RPC 难以透明的物理障碍（网络错误、时延、内存隔离）。

#### 第二章解析
9.  **C**。**拜占庭核心**。A 错，两将军也是不可靠信道。B 错，两将军问题无解（No Solution）。D 错，拜占庭主要处理恶意节点，信道丢包属于网络模型范畴。
10. **C**。**7个**。公式 $N \ge 3f + 1$。$f=2$，则 $N \ge 3 \times 2 + 1 = 7$。
11. **B**。**Fair-loss 定义**。PPT 并没有深入讲数学定义，但核心意思是：只要你坚持不懈地发，且链路没断，消息最终会到达。这是实现可靠传输（如 TCP）的理论基础。
12. **C**。**Crash-stop**。这是最简单的模型，因为节点一旦死了就不再捣乱，也不诈尸（重启），状态最确定。Byzantine 最难。
13. **B**。**同步定义**。同步不仅要求时钟有一定同步，更核心的是**操作和消息传输都有时间上界**。
14. **B**。**FLP 不可能性/故障检测限制**。在异步系统中，没有时间上界，因此你永远不知道对方是不理你（慢）还是死了（Crash）。这是所有分布式共识算法在异步环境下面临的根本挑战。
15. **D**。**CPU 频率**。CPU 频率固定是有利于预测时间的。ABC（GC、Swap、网络拥塞）都是 PPT P26 列举的导致延迟不可预测的“罪魁祸首”。
16. **C**。**最终完美**。PPT P29。重点在于“Eventually”（最终）。它允许中间通过心跳超时误判节点挂了（False Positive），但只要给足够时间，它最终能收敛到正确状态。这适用于部分同步系统。

---


#### 第三章：时间与时钟 (深度复习)

---

### 第一部分：核心知识点摘要（干货版）

1.  **物理时钟 (Physical Clocks)**
    *   **石英钟**：存在**漂移 (Drift)**，受温度影响。精度用 ppm (百万分率) 衡量。
    *   **原子钟**：基于铯-133，极其精准（TAI 国际原子时）。
    *   **UTC (协调世界时)**：TAI + 闰秒（为了匹配地球自转）。
    *   **闰秒问题**：计算机处理闰秒可能导致崩溃（Linux 活锁案例）。解决方案：**Smearing**（把1秒拉长/缩短分摊到一天中）。
2.  **计算机时钟分类**（常考选择题）：
    *   **日历时钟 (Wall Clock/Real-time Clock)**：表示绝对日期（如 `System.currentTimeMillis()`）。可能**回拨**（跳变），不适合测量时间间隔。
    *   **单调时钟 (Monotonic Clock)**：从开机起算（如 `System.nanoTime()`）。**永不回拨**，适合测量持续时间（Duration）。
3.  **NTP (网络时间协议)**
    *   **分层 (Stratum)**：Stratum 0 是原子钟，Stratum 1 直连原子钟，以此类推。
    *   **同步算法 (重点)**：计算 **Round-trip delay ($\delta$)** 和 **Offset ($\theta$)**。
    *   **校准方式**：
        *   偏差 < 125ms：**Slewing (微调/平滑调整)**，改变频率追赶。
        *   125ms < 偏差 < 1000s：**Stepping (跳变)**，直接重置时间。
        *   偏差 > 1000s：**Panic**，人工干预。
4.  **逻辑时间与排序 (Logical Time)**
    *   **问题**：物理时钟无法完美同步，不能用于判断分布式系统中事件的先后。
    *   **Happens-Before 关系 ($\rightarrow$)**：
        1.  **本地**：同一进程内，先执行的在前。
        2.  **消息**：发送事件 $a$ 先于接收事件 $b$ ($a \rightarrow b$)。
        3.  **传递性**：$a \rightarrow b$ 且 $b \rightarrow c$，则 $a \rightarrow c$。
    *   **并发 (Concurrent, $a || b$)**：如果 $a \nrightarrow b$ 且 $b \nrightarrow a$，则称两个事件并发。**也就是在时空图中，彼此看不到对方（不在对方的光锥内）。**

---

### 第二部分：高频考点预测

1.  **大题考点预测**：
    *   **NTP 计算**：给出一张图或四个时间戳（$t_1, t_2, t_3, t_4$），让你计算**网络往返延迟**和**时钟偏差**。这是本章最硬的计算题。
    *   **Happens-Before 判定**：给出时空图，问你哪些事件是并发的？哪些事件有因果关系？（这是 Lamport 时间戳的前置知识）。
2.  **易错点**：
    *   **单调时钟 vs 日历时钟**：代码填空或选择题里，算耗时必须用单调时钟。
    *   **同步假设**：Cristian 算法（NTP的基础）假设**请求和响应的网络延迟是对称的**（即去和回的时间相等），实际上很难完全满足。

---

### 第三部分：模拟实战题库

#### 🔴 大题实战（针对考点：NTP计算 & 事件排序）

**【大题 1】NTP 时间同步计算（10分）**
假设客户端 A 向时间服务器 B 发送请求以进行时钟同步。记录的时间戳如下（单位：ms）：
*   客户端 A 发送请求时刻 $t_1 = 1000$
*   服务器 B 接收请求时刻 $t_2 = 1200$
*   服务器 B 发送响应时刻 $t_3 = 1210$
*   客户端 A 接收响应时刻 $t_4 = 1050$

**问题：**
1.  (3分) 计算客户端 A 和服务器 B 之间的网络往返延迟 $\delta$ (Round-trip delay)。
2.  (3分) 计算客户端 A 相对于服务器 B 的时钟偏差 $\theta$ (Offset)。(即：服务器时间 - 客户端时间)
3.  (4分) 如果客户端计算出的偏差 $\theta$ 为 +500ms，且系统设定采用“微调 (Slewing)”的阈值是 125ms，客户端应该如何调整自己的时钟？

**【答案与解析】**
1.  **往返延迟 $\delta$**：
    *   公式：$\delta = (t_4 - t_1) - (t_3 - t_2)$
    *   计算：$(1050 - 1000) - (1210 - 1200) = 50 - 10 = 40 \text{ ms}$。
    *   *解析：总耗时减去服务器处理耗时，就是路上的时间。*
2.  **时钟偏差 $\theta$**：
    *   公式：$\theta = \frac{(t_2 - t_1) + (t_3 - t_4)}{2}$
    *   计算：$\frac{(1200 - 1000) + (1210 - 1050)}{2} = \frac{200 + 160}{2} = \frac{360}{2} = 180 \text{ ms}$。
    *   *解析：这意味着服务器的时间比客户端快 180ms。或者理解为：估计 B 收到消息时，A 的时间应该是 $t_1 + \delta/2 = 1000 + 20 = 1020$。而 B 实际是 $1200$。所以偏差是 $1200 - 1020 = 180$。*
3.  **调整策略**：
    *   题目假设偏差为 +500ms（注意不是用第2问的结果，而是新假设）。
    *   500ms > 125ms (微调阈值)。
    *   因此，**客户端应采用“跳变 (Stepping)”方式**。
    *   具体操作：**立即将客户端时钟向后调整（调快）**，重置为估计的服务器时间。
    *   *注：PPT P26 提到 125ms 到 1000s 之间采用跳变。*

---

**【大题 2】Happens-Before 关系判定（10分）**
如下图所示，有三个进程 P1, P2, P3。箭头表示消息传递。黑点表示事件。

```text
    P1      P2      P3
    |       |       |
 a  *       |       |
    | \ m1  |       |
    |  \    |       |
 b  *   --->* c     |
    |       | \ m2  |
    |       |  \    |
    |       * d --->* e
    |       |       |
 f  *       |       |
    |       |       |
```
(注：图中 $a$ 在 $b$ 之前，$c$ 在 $d$ 之前。$m1$ 从 $P1$ 发到 $P2$，$m2$ 从 $P2$ 发到 $P3$)

**问题：**
1.  (3分) 写出事件 $a$ 和 $e$ 的关系（是 $a \rightarrow e$，$e \rightarrow a$，还是 $a || e$？），并说明理由。
2.  (3分) 写出事件 $f$ 和 $c$ 的关系，并说明理由。
3.  (4分) 请列出图中所有与事件 $b$ **并发 (Concurrent)** 的事件。

**【答案与解析】**
1.  **$a \rightarrow e$**。
    *   理由：根据传递性。同一进程内 $a \rightarrow b$ (假设a在b前)。消息发送 $b \rightarrow c$。同一进程 $c \rightarrow d$。消息发送 $d \rightarrow e$。
    *   所以 $a \rightarrow b \rightarrow c \rightarrow d \rightarrow e$，故 $a \rightarrow e$。
2.  **$f || c$ (并发)**。
    *   理由：$f$ 是 P1 上的后续事件，无法通过任何消息路径到达 $c$；反之 $c$ 也无法到达 $f$。它们互不影响，不在对方的因果历史中。
3.  **并发事件：$c, d, e$** (假设图中 f 在 b 之后很远，且没有消息回传给 P1)。
    *   *修正*：看图，与 $b$ 并发的事件是那些“既不是 $b$ 的因果前序，也不是 $b$ 的因果后继”的事件。
    *   $b \rightarrow c$，所以 $c$ 不是并发。
    *   $b \rightarrow d \rightarrow e$，所以 $d, e$ 不是并发。
    *   **实际上图里除了P1自己的事件，P2/P3的事件都在b之后。**
    *   *让我们换一个更典型的并发例子*：假设 P3 有个事件 $g$ 在 $e$ 之前，且没有任何消息指向 $g$。那么 $g$ 和 $b$ 就是并发的。
    *   *针对本图的严格回答*：如果图中没有画出 P3 上的前序事件，且 P2 的 $c$ 是由 $b$ 触发的，那么 $b$ 是 $c, d, e$ 的“因果前驱 (Happens-Before)”。
    *   *如果题目问的是 $f$ (P1上比b晚发生的事件)*：那么 $c, d, e$ 很可能与 $f$ 并发（因为 $m1$ 发出去后，P1 继续跑 $f$，P2 跑 $c$，谁快谁慢不知道）。
    *   **答案**：与 $f$ 并发的是 $c, d, e$（除非有消息从 P2/P3 传回 P1）。

---

#### 🔵 选择题精选（针对非大题考点，每题2分）

**1. 关于“闰秒 (Leap Second)”，PPT 中提到的 Google/Amazon 等公司的处理方式（Smearing）是指？**
A. 在闰秒发生的那一刻，让系统时钟暂停1秒
B. 在闰秒发生时，强制将时钟回调1秒
C. 将增加的1秒均匀分摊到这一天（或一段时间）内，使时钟变慢一点点，从而避免突然跳变
D. 忽略闰秒，直接使用 GPS 时间

**2. 在 Java 或 Linux 编程中，若要计算一段代码执行了多长时间（Duration），应该使用哪种时钟？**
A. Wall Clock (如 `System.currentTimeMillis`)
B. Monotonic Clock (如 `System.nanoTime`)
C. NTP Clock
D. Atomic Clock

**3. NTP 协议中的 Stratum 2 服务器是指？**
A. 直接连接原子钟的服务器
B. 与 Stratum 1 服务器进行同步的服务器
C. 精度最低的服务器
D. 负责管理 Stratum 1 的服务器

**4. Cristian 算法（NTP 的基础）在计算时钟偏差 $\theta$ 时，做了一个关键假设，这个假设是？**
A. 客户端的处理速度比服务器快
B. 客户端和服务器的时钟频率完全一致
C. 请求消息传输的时间 和 响应消息传输的时间 相等（网络延迟对称）
D. 网络中不存在丢包

**5. 在 Lamport 的 Happens-Before 关系中，如果事件 $a$ 和 $b$ 满足 $a || b$（并发），这意味着？**
A. $a$ 和 $b$ 在同一物理时刻发生
B. $a$ 和 $b$ 发生在同一台机器上
C. $a$ 无法影响 $b$，且 $b$ 也无法影响 $a$（彼此不知道对方的存在）
D. 系统必然会发生错误

**6. 为什么日历时钟（Wall Clock）不适合用于测量“超时（Timeout）”或“耗时”？**
A. 因为它的精度只有毫秒级
B. 因为它可能会因为 NTP 同步而发生“跳变”或“回拨”，导致计算出的耗时为负数
C. 因为它不包含闰秒
D. 因为它在 2038 年会溢出

**7. 在 NTP 算法中，如果计算出的往返延迟 $\delta$ 很大，这通常意味着什么？**
A. 计算出的时钟偏差 $\theta$ 精度很高
B. 计算出的时钟偏差 $\theta$ 误差范围可能也很大（不确定性增加）
C. 服务器已经崩溃
D. 必须立即切换到 GPS 时间源

**8. 根据 PPT，如果两台计算机的时钟偏差（Skew）超过了 1000秒，NTP 客户端通常会采取什么措施？**
A. 立即进行 Stepping（跳变）调整
B. 加快时钟频率进行 Slewing（微调）
C. Panic（恐慌模式），不做自动调整，报错等待人工干预
D. 自动重启计算机

---

### ✅ 选择题答案
1.  **C** (Smearing 是为了避免活锁，把1秒拉长分摊)
2.  **B** (单调时钟永不回退，适合算耗时)
3.  **B** (Stratum 0=原子钟, 1=连原子钟, 2=连Stratum 1)
4.  **C** (NTP 计算 $\theta$ 时除以了2，默认去程和回程各占一半)
5.  **C** (并发的物理意义：在光锥之外，没有因果联系)
6.  **B** (PPT P29 明确代码示例，`elapsedMillis` 可能是负数)
7.  **B** (PPT P15 提到：误差取决于单向延迟，而我们只知道 RTT，RTT 越大，不对称的可能性越大，误差上下界越大)
8.  **C** (PPT P27 明确提到 >1000s 进入 Panic)

---

## 第四章：广播协议与逻辑时间戳

---

### 第一部分：核心知识点摘要（大题必背）

#### 1. 逻辑时间戳 (Logical Timestamps)
*   **Lamport 时间戳**：
    *   **算法**：
        1.  本地事件：计数器 `t = t + 1`。
        2.  发送消息：带上 `t`，然后 `t = t + 1`。
        3.  接收消息 $(t_{msg})$：**`t = max(t, t_msg) + 1`**。
    *   **缺点**：$T(a) < T(b)$ **推导不出** $a \rightarrow b$（可能是并发）。
*   **向量时间戳 (Vector Clocks)**：
    *   **结构**：每个进程维护一个数组 $V[1..N]$。
    *   **算法**：
        1.  本地事件：`V[i] = V[i] + 1`（只加自己的分量）。
        2.  发送消息：带上整个向量 $V$。
        3.  接收消息 $(V_{msg})$：对于所有 $k$，**`V[k] = max(V[k], V_msg[k])`**，然后 **`V[i] = V[i] + 1`**。
    *   **并发判断**：如果 $V_1$ 和 $V_2$ 互不小于（即有的分量 $V_1$ 大，有的 $V_2$ 大），则为并发。

#### 2. 多播排序 (Multicast Ordering)
*   **FIFO 排序 (先入先出)**：
    *   **定义**：只管**同一个发送者**。如果 P1 先发 m1 后发 m2，所有人都必须先交 m1 后交 m2。
    *   **判断**：看来源节点的序列号是否连续。
*   **Causal Ordering (因果排序)**：
    *   **定义**：如果 $m1 \rightarrow m2$（有因果关系），所有人必须先交 m1。
    *   **实现条件 (重点)**：接收方 $P_i$ 收到来自 $P_j$ 的消息 $M$ (附带向量 $V_M$)，能交付的条件是：
        1.  $V_M[j] == V_{local}[j] + 1$ (这是 $P_j$ 的下一条消息)
        2.  对于所有 $k \neq j$， $V_M[k] \le V_{local}[k]$ (没错过其他人的因果前序消息)
*   **Total Ordering (全序/原子广播)**：
    *   **定义**：所有人看到的顺序**一模一样**（不管符不符合 FIFO/因果）。
    *   **实现**：通常用 Sequencer（定序器/Leader）来分配全局序号。

---

### 第二部分：高频大题预测（硬核计算题）

#### 【大题 1】Lamport 与 向量时间戳计算（10分）
**题目描述：**
现有三个进程 P1, P2, P3。初始时间戳均为 0（Lamport 为 0，向量为 [0,0,0]）。
发生的事件如下：
1.  P1 发送消息 $m_1$ 给 P2。
2.  P2 收到 $m_1$。
3.  P2 发送消息 $m_2$ 给 P3。
4.  P3 收到 $m_2$。
5.  P3 发送消息 $m_3$ 给 P1。
6.  P1 收到 $m_3$。
7.  在此期间，P1 在发送 $m_1$ 之前发生了一次本地事件 $e_1$。

**问题：**
1.  **(5分) Lamport 时间戳**：请计算上述 7 个事件发生后的 Lamport 时间戳数值。
2.  **(5分) 向量时间戳**：请计算上述 7 个事件发生后的向量时间戳数值。

**【答案与解析】**

**1. Lamport 时间戳计算：**
*   规则：本地 `+1`，接收 `max(本地, 消息) + 1`。
*   P1: 本地事件 $e_1$ $\rightarrow$ **1**
*   P1: 发送 $m_1$ $\rightarrow$ $1+1 =$ **2** (携带 2)
*   P2: 收到 $m_1$ $\rightarrow$ `max(0, 2) + 1` = **3**
*   P2: 发送 $m_2$ $\rightarrow$ $3+1 =$ **4** (携带 4)
*   P3: 收到 $m_2$ $\rightarrow$ `max(0, 4) + 1` = **5**
*   P3: 发送 $m_3$ $\rightarrow$ $5+1 =$ **6** (携带 6)
*   P1: 收到 $m_3$ $\rightarrow$ `max(2, 6) + 1` = **7** (注意 P1 当前是 2)

**2. 向量时间戳计算 (格式 [P1, P2, P3])：**
*   规则：发消息/本地事件给自己分量 `+1`；收消息先 `max` 各分量，再给自己 `+1`。
*   P1: 本地事件 $e_1$ $\rightarrow$ **[1, 0, 0]**
*   P1: 发送 $m_1$ $\rightarrow$ **[2, 0, 0]** (携带 [2,0,0])
*   P2: 收到 $m_1$ $\rightarrow$ 对比 P2本地[0,0,0] 和 消息[2,0,0] $\rightarrow$ max得[2,0,0] $\rightarrow$ P2分量+1 $\rightarrow$ **[2, 1, 0]**
*   P2: 发送 $m_2$ $\rightarrow$ **[2, 2, 0]** (携带 [2,2,0])
*   P3: 收到 $m_2$ $\rightarrow$ 对比 P3本地[0,0,0] 和 消息[2,2,0] $\rightarrow$ max得[2,2,0] $\rightarrow$ P3分量+1 $\rightarrow$ **[2, 2, 1]**
*   P3: 发送 $m_3$ $\rightarrow$ **[2, 2, 2]** (携带 [2,2,2])
*   P1: 收到 $m_3$ $\rightarrow$ 对比 P1本地[2,0,0] 和 消息[2,2,2] $\rightarrow$ max得[2,2,2] $\rightarrow$ P1分量+1 $\rightarrow$ **[3, 2, 2]**

---

#### 【大题 2】多播排序与交付判断（10分）
**题目描述：**
在一个多播组中，有三个进程 P1, P2, P3。系统使用 **因果排序 (Causal Ordering)** 协议（基于向量时间戳实现）。
当前 P3 的本地向量时间戳为 **[2, 4, 1]**（意味着 P3 已经交付了 P1 的 2 条消息，P2 的 4 条消息，P3 自己的 1 条）。

此时，P3 的接收缓冲区中收到了两条来自 P1 的新消息：
*   消息 A：来自 P1，携带向量 **[3, 4, 1]**
*   消息 B：来自 P1，携带向量 **[4, 4, 1]**

**问题：**
1.  **(3分)** 消息 A 是否可以立即交付？请根据因果排序的两个条件进行验证。
2.  **(3分)** 假设 P3 收到的不是消息 A，而是收到一条来自 P2 的消息 C，携带向量 **[2, 6, 1]**。消息 C 能否立即交付？为什么？
3.  **(4分)** 请解释“因果排序”与“FIFO 排序”的关系。如果一个协议满足因果排序，它一定满足 FIFO 吗？反之成立吗？

**【答案与解析】**

**1. 消息 A 可以立即交付。**
*   **条件1 (来源连续性)**：消息来自 P1。$V_{msg}[1] = 3$。$P3_{local}[1] = 2$。$3 = 2 + 1$，满足（这是 P3 期待的下一条 P1 消息）。
*   **条件2 (无遗漏其他)**：检查其他分量。
    *   $V_{msg}[2] = 4 \le P3_{local}[2] = 4$ (满足)
    *   $V_{msg}[3] = 1 \le P3_{local}[3] = 1$ (满足)
*   **结论**：所有条件满足，交付。

**2. 消息 C 不能立即交付，必须缓存。**
*   **分析**：消息来自 P2。$V_{msg}[2] = 6$。$P3_{local}[2] = 4$。
*   **判断**：$6 \neq 4 + 1$。中间缺了序号为 5 的消息。
*   **结论**：违反了来源连续性条件（或者说检测到了消息丢失/乱序），必须等待向量为 [..., 5, ...] 的消息交付后才能处理 C。

**3. 关系解释：**
*   **因果排序 $\Rightarrow$ FIFO 排序**：是的。如果协议满足因果排序，它一定满足 FIFO。因为同一个发送者发出的 $m1$ 和 $m2$，必然有 $m1 \rightarrow m2$（因果关系），所以因果协议会保证顺序。
*   **FIFO 排序 $\nRightarrow$ 因果排序**：反之不成立。FIFO 只保证同一个人的消息不乱，但无法处理不同人之间的因果依赖（比如 P1 发给 P2，P2 再发给 P3，P3 可能先收到 P2 的后收到 P1 的，这符合 FIFO 但违反因果）。

---

### 第三部分：选择题精选（易错概念）

**1. 关于 Lamport 逻辑时钟，下列说法正确的是？**
A. 如果 $T(a) < T(b)$，则一定有事件 $a$ 先于 $b$ 发生 ($a \rightarrow b$)
B. 如果事件 $a \rightarrow b$，则一定有 $T(a) < T(b)$
C. Lamport 时钟可以用来完美检测并发事件
D. Lamport 时钟要求所有节点必须物理时钟同步

**2. 向量时间戳 $V_1 = [2, 2, 0]$ 和 $V_2 = [2, 3, 1]$ 之间的关系是？**
A. $V_1 < V_2$
B. $V_2 < V_1$
C. $V_1$ 和 $V_2$ 并发 ($V_1 || V_2$)
D. 无法比较

**3. 下列哪种多播排序协议的实现通常需要一个中心化的 Sequencer（定序器）？**
A. FIFO Ordering
B. Causal Ordering
C. Total Ordering (全序)
D. Best-effort Broadcast

**4. 在实现因果排序（Causal Ordering）时，如果接收到的消息的向量时间戳显示 $V_{msg}[k] > V_{local}[k]$（其中 $k$ 不是发送者），这意味着什么？**
A. 发送者发送了重复的消息
B. 接收方丢失了（或尚未收到）来自节点 $k$ 的某条消息，该消息在因果上先于当前消息
C. 网络发生了分区
D. 这是正常的，可以直接交付消息

**5. 为什么说“物理时间戳”不能完全替代“逻辑时间戳”来解决事件排序问题？**
A. 因为物理时钟精度不够高
B. 因为物理时钟无法处理闰秒
C. 因为即使使用 NTP，不同节点的物理时钟仍存在误差，可能导致 $T(a) < T(b)$ 但实际上 $b$ 先发生
D. 因为物理时钟太贵了

**6. 对于三个进程 P1, P2, P3，P1 发送 m1，P1 发送 m2。P2 先收到 m2，后收到 m1。这种现象违反了哪种排序？**
A. 仅违反了全序
B. 仅违反了因果排序
C. 违反了 FIFO 排序（同时也违反了因果排序）
D. 没有违反任何排序，因为网络是异步的

**7. 在向量时间戳中，如果进程 $P_i$ 的本地向量是 $V$，当它发送一个消息时，它会如何更新自己的向量？**
A. 不更新，直接发送副本
B. 将向量中所有元素都加 1
C. 仅将第 $i$ 个分量 ($V[i]$) 加 1
D. 随机选择一个分量加 1

---

### ✅ 选择题答案
1.  **B** (A 是 Lamport 的最大缺陷，无法推导因果；C 错，向量时钟才能检测并发)
2.  **A** (2=2, 2<3, 0<1，每一项都小于等于，且有小于项，所以 V1 -> V2)
3.  **C** (全序要求所有人顺序一致，通常由 Leader/Sequencer 决定顺序)
4.  **B** (这意味着发送者“看到”了节点 k 的某些动作，而接收者还没“看到”，为了维持因果，接收者必须等 k 的消息到了才能处理当前消息)
5.  **C** (PPT P2 和 P40 专门讲了这个图，"准时是相对的，误差是绝对的")
6.  **C** (同一个发送者乱序，最直接违反 FIFO。由于 FIFO 是因果的子集，所以也违反因果)
7.  **C** (PPT P33 规则：本地/发送事件，只增加自己的计数器)

## 第五章：副本

### 第一部分：核心知识点摘要（仅针对选择题）

1.  **重试与幂等**：
    *   **At-most-once**：不重试，数据可能丢，但绝不重复。
    *   **At-least-once**：一直重试直到成功，数据绝不丢，但可能重复。
    *   **Exactly-once**：目标。通常通过 **At-least-once + 幂等性/去重** 实现。
    *   **幂等操作**：执行多次效果等于一次（如 `set x=5`, `add to Set`）。`x++` 不是幂等。

2.  **副本与一致性**：
    *   **副本 (Replica)**：多节点存同一份数据，为了容错和分担负载（而不是为了计算加速，那是分片）。
    *   **墓碑 (Tombstone)**：逻辑删除标记。解决“真删除后，旧副本把数据同步回来复活”的问题。
    *   **读写一致性 (Read-your-writes)**：保证用户自己能读到自己刚写的。
    *   **单调读 (Monotonic Reads)**：保证用户不会读到“时光倒流”的数据。

3.  **仲裁机制 (Quorum)**：
    *   公式：**$W + R > N$**（读写集合必须有交集）。
    *   **ROWA (Read One Write All)**：$W=N, R=1$。读极快，写最慢且容错差。
    *   **多数派**：$W = R = (N+1)/2$。容忍少数节点挂掉。

4.  **反熵 (Anti-entropy) vs 读时修复**：
    *   **读时修复**：客户端读的时候发现不一致，顺手修了（懒加载）。
    *   **反熵**：后台进程定期对比修数据（如 Merkle Tree）。

---

### 第二部分：模拟实战题库（全选择题，覆盖所有细节）

**1. 在分布式系统中，关于“副本 (Replication)”的主要目的，下列说法最准确的是？**
A. 为了利用多核 CPU 进行并行计算
B. 为了提高系统的可用性（Availability）和读取性能
C. 为了将一份大数据拆分成小块存储在不同机器上（Sharding）
D. 为了实现完全的自动化运维

**2. 一个操作如果满足 $f(f(x)) = f(x)$，我们称之为“幂等”的。下列哪个数据库操作通常被认为是幂等的？**
A. `INSERT INTO logs (message) VALUES ('error')` (自增主键)
B. `UPDATE account SET balance = balance + 10 WHERE id = 1`
C. `UPDATE account SET balance = 100 WHERE id = 1`
D. `append(list, element)`

**3. 在实现“恰好一次 (Exactly-once)”语义时，通常采用的策略是？**
A. 仅使用 TCP 协议即可自动保证
B. 使用 At-most-once 策略，因为这样最安全
C. 使用 At-least-once 策略，配合服务端去重（Deduplication）或幂等性设计
D. 只要客户端不重试，就能保证恰好一次

**4. 为什么在分布式存储系统中，删除数据通常采用“墓碑 (Tombstone)”标记而不是物理删除？**
A. 为了保留数据备份以防误删
B. 为了提高磁盘写入速度（顺序写）
C. 防止在反熵 (Anti-entropy) 或同步过程中，旧的副本将已删除的数据“复活”
D. 为了方便管理员审计

**5. 在一个包含 $N=5$ 个副本的系统中，如果采用了仲裁机制 (Quorum Consensus)，且配置写入仲裁数 $W=3$。为了保证强一致性（即读到最新写入），读取仲裁数 $R$ 至少应该是多少？**
A. 1
B. 2
C. 3
D. 5

**6. 关于仲裁机制中的配置 $W=N, R=1$ (Write All, Read One)，下列评价正确的是？**
A. 写入性能极高，读取性能极低
B. 系统的容错性极高，任何节点挂了都能继续写入
C. 只要有一个副本故障，写入操作就会失败（可用性差）
D. 无法保证一致性

**7. 某用户在刷微博时，刚发了一条微博，刷新页面却发现自己刚发的微博不见了（读不到），过了一会儿才出现。这违反了哪种一致性模型？**
A. 最终一致性 (Eventual Consistency)
B. 写后读一致性 (Read-your-writes Consistency)
C. 因果一致性 (Causal Consistency)
D. 单调读一致性 (Monotonic Reads)

**8. “读时修复 (Read Repair)” 机制通常发生在什么时刻？**
A. 系统空闲时，后台进程定期扫描
B. 客户端发起写请求时
C. 客户端发起读请求，且从不同副本读到了不一致的数据时
D. 数据库启动时

**9. 在处理并发写入时，Last Writer Wins (LWW) 策略的主要缺点是？**
A. 需要所有节点时钟完全同步
B. 可能会导致部分并发写入的数据丢失
C. 实现极其复杂
D. 无法处理网络分区

**10. 状态机复制 (State Machine Replication, SMR) 要求所有副本以相同的初始状态开始，并以相同的顺序接收相同的输入。为了实现这一点，底层的广播协议必须满足？**
A. 尽力而为广播 (Best-effort Broadcast)
B. FIFO 广播
C. 全序广播 (Total Order Broadcast)
D. 因果广播 (Causal Broadcast)

---

### ✅ 答案与解析

1.  **B** (A是并行计算，C是分片/Sharding)。
2.  **C** (设置绝对值是幂等的。A/B/D重复执行都会导致数据增加或重复)。
3.  **C** (这是标准做法。A TCP只保证传输层，应用层重试会导致重复)。
4.  **C** (物理删除后，该记录消失。同步时，系统会认为拥有旧数据的副本是“更新”的（因为它有数据而你没有），从而把数据同步回来)。
5.  **C** (公式 $W+R > N \Rightarrow 3+R > 5 \Rightarrow R > 2$，所以 $R$ 至少是 3)。
6.  **C** (ROWA 模型。读性能最好，但只要坏一个节点，$W=N$ 就无法满足，写服务不可用)。
7.  **B** (写后读一致性保证：自己写，自己立马能读到)。
8.  **C** (A是反熵。Read Repair 是懒加载式的修复)。
9.  **B** (LWW 简单粗暴，时间戳晚的覆盖早的，如果两个并发写各有部分新数据，LWW 会全盘丢弃其中一个)。
10. **C** (SMR 的核心就是“顺序一致”，只有全序广播能保证所有节点看到的顺序一模一样)。

---

## 第六章：一致性

---

### 第一部分：核心知识点摘要（选择题考点）

1.  **一致性 (Consistency) 的多重含义**：
    *   **ACID 中的 C**：指**业务规则/不变式**（Invariants）不被破坏（例如：课必须有老师）。这是**应用层**的一致性。
    *   **分布式系统中的 C (CAP/Linearizability)**：指**多副本看起来像一个副本**。这是**存储层**的一致性。
    *   **写后读一致性 (Read-after-write)**：保证**自己**能读到**自己**刚才写的数据（不保证别人）。

2.  **原子提交与 2PC (两阶段提交)**：
    *   **目标**：要么所有节点都提交，要么都回滚（原子性）。
    *   **流程**：
        1.  **准备阶段 (Vote/Prepare)**：协调者问“能提交吗？”，参与者锁定资源，写日志，回复 Yes/No。
        2.  **提交阶段 (Commit/Abort)**：协调者根据收集结果（全 Yes 则 Commit，任一 No 则 Abort）发指令。
    *   **致命弱点 (Blocking)**：**阻塞性**。如果协调者在发送最终决定前崩溃，参与者会一直持有锁并阻塞，无法自行决定。

3.  **线性一致性 (Linearizability)**：
    *   **定义**：最强的一致性。所有操作看起来像是瞬间完成的，且所有节点看到的操作顺序一致。
    *   **ABD 算法**：在异步网络 + 多数派（Quorum）系统中实现线性一致性的算法。
        *   核心：**读操作需要两个阶段（Query + Write-back）**。
        *   **读时回写 (Write-back)**：如果你读到了一个“新”数据，在返回给客户端之前，要先把这个数据写回多数派，确保后续读操作也能读到它。

4.  **状态机复制 (SMR)**：
    *   **原理**：相同的初始状态 + 相同的输入序列（通过**全序广播**保证）+ 确定性逻辑 = 相同的最终状态。
    *   **全序广播 (Total Order Broadcast)**：是实现 SMR 和线性一致性 CAS (Compare-and-Swap) 的基础。

---

### 第二部分：模拟实战题库（全选择题）

**1. 在数据库事务 ACID 属性中，“一致性 (Consistency)”的具体含义是？**
A. 所有副本的数据在任何时刻都是完全相同的
B. 事务必须将数据库从一个满足业务规则（不变式）的状态转换到另一个满足业务规则的状态
C. 读操作保证能读到最近一次写入的值
D. 事务的执行过程是原子的，不可分割

**2. 关于“写后读一致性 (Read-after-write Consistency)”，下列描述正确的是？**
A. 它属于强一致性（Strong Consistency）的一种
B. 它保证所有用户都能立即看到最新的写入
C. 它仅保证**执行写入操作的那个客户端**能立即读到自己刚才写入的数据
D. 它要求系统必须使用 2PC 协议

**3. 两阶段提交协议 (2PC) 的最大缺点是？**
A. 无法保证原子性
B. 这是一个**阻塞协议 (Blocking Protocol)**，如果协调者崩溃，参与者可能被迫一直等待
C. 消息量太少，不够可靠
D. 只能处理读操作，不能处理写操作

**4. 在 2PC 的第一阶段（准备阶段），如果参与者回复了 "Vote Commit"（同意提交），这意味着？**
A. 该参与者已经成功提交了事务
B. 该参与者已经将数据写入磁盘，并承诺**无论发生什么（即使自己崩溃重启）**，只要协调者要求提交，它就能提交
C. 该参与者认为数据没有问题，但还没有写入磁盘
D. 该参与者可以随时单方面决定回滚事务

**5. 线性一致性 (Linearizability) 要求系统对外表现得像？**
A. 有多个副本，且副本之间通过 Gossip 协议同步
B. 只有一个数据副本，且所有操作都是原子且瞬时的
C. 只要最终一致即可
D. 读操作总是返回旧数据

**6. ABD 算法是为了解决什么问题而提出的？**
A. 在同步系统中实现 2PC
B. 在异步且不可靠的网络中，通过 Quorum 机制实现**线性一致性**的读写
C. 实现状态机复制 (SMR)
D. 解决拜占庭将军问题

**7. 为什么 ABD 算法中的“读”操作有时需要执行“回写 (Write-back)”步骤？**
A. 为了备份数据
B. 为了确保读到的数据在后续的读操作中依然可见（防止“旧读”现象破坏线性一致性）
C. 为了通知写操作的客户端“我读到了”
D. 为了增加网络负载

**8. 状态机复制 (SMR) 能够正常工作的一个关键前提是？**
A. 所有副本的物理时钟必须完全同步
B. 所有副本处理请求的逻辑必须是**确定性 (Deterministic)** 的
C. 必须使用 UDP 协议进行通信
D. 副本数量必须是偶数

**9. 在基于全序广播 (Total Order Broadcast) 实现的容错 2PC 中，如果某个参与者被怀疑崩溃了，其他节点会怎么做？**
A. 无限期等待该节点恢复
B. 代替该节点发送一个 "Vote False" (反对票)，从而触发全局回滚，避免阻塞
C. 强制提交事务
D. 选举一个新的协调者

**10. 下列关于“线性一致性”与“可串行化 (Serializability)”的区别，正确的是？**
A. 两者是同一个概念的不同叫法
B. 线性一致性是关于单对象、单操作的实时性保证；可串行化是关于多对象、多操作事务的隔离性保证
C. 可串行化比线性一致性更强
D. 线性一致性允许读到旧数据

---

### ✅ 答案与解析

1.  **B** (A是副本一致性/线性一致性；C是线性一致性；D是原子性。ACID的C特指业务逻辑合法)。
2.  **C** (A错，它通常属于客户端中心的一致性，比强一致性弱；B错，那是线性一致性)。
3.  **B** (PPT P18 重点强调。协调者挂了+参与者投了Yes = 参与者死锁)。
4.  **B** (承诺书。一旦说 Yes，命就是协调者的了，必须持久化状态以防崩了忘了)。
5.  **B** (PPT P23 定义。Single copy image)。
6.  **B** (PPT P46。ABD 是在 Quorum 基础上加了 Write-back 来实现 Linearizability)。
7.  **B** (PPT P53。如果只读不写回，可能出现：客户端A读到了新值（因为运气好读到了新副本），A告诉B，结果B去读时运气不好只读到了旧副本。这违反了线性一致性。回写保证了“一旦被读到，就真的持久了”)。
8.  **B** (PPT P55。如果逻辑不确定（如使用了随机数、本地时间），同样的输入会导致不同的状态)。
9.  **B** (PPT P20/22。这是**容错 2PC** 对 **经典 2PC** 的改进，用“怀疑即反对”来解决阻塞)。
10. **B** (PPT P23 注意事项。Linearizability = Real-time constraints on registers; Serializability = Isolation properties of transactions)。

---

**复习提示**：
*   **ABD算法**：记住“读也需要写（Write-back）”这一反直觉的特性。
*   **2PC**：记住“阻塞”是它最大的锅。

## 第七章：共识

---

### 第一部分：核心知识点摘要（大题必背）

#### 1. 原子提交 (Atomic Commit) vs 共识 (Consensus)
这是概念对比题的重点，一定要背熟区别：

| 特性         | 原子提交 (如 2PC)                                             | 共识 (Consensus)                                                 |
| :----------- | :------------------------------------------------------------ | :--------------------------------------------------------------- |
| **目标**     | **全员一致**：所有节点必须同意。                              | **多数派一致**：超过半数同意即可。                               |
| **故障容忍** | **0容忍**：只要有一个节点投反对或崩溃，必须全体中止 (Abort)。 | **容忍少数**：即使有节点崩溃或投反对票，只要凑够多数派就能通过。 |
| **提出值**   | 每个节点都投票决定自己的提交/中止。                           | 一个或多个节点提出一个值 (Proposal)。                            |
| **最终决定** | 所有人都 Yes 才是 Yes。                                       | 选出的值必须是某人提出的值。                                     |

#### 2. 环选举算法 (Ring Election Algorithm) —— **计算题核心**
*   **模型**：$N$ 个节点组成环，单向通信。
*   **规则**：
    *   发起者发送包含自己 `id` 的 `Election` 消息。
    *   收到消息者：
        *   若 `msg.id > self.id`：转发。
        *   若 `msg.id < self.id`：如果自己没发过，替换成自己的 `id` 转发；否则丢弃（PPT P17/36 多发起者优化）。
        *   若 `msg.id == self.id`：自己选上了！发送 `Elected` 消息通知全员。
*   **复杂度分析 (必须会推导)**：
    *   **最好情况 (Best Case)**：**$2N$** 条消息。
        *   场景：**ID 最大的节点**自己发起选举。
        *   推导：`Election` 转一圈 ($N$) + `Elected` 转一圈 ($N$) = $2N$。
    *   **最坏情况 (Worst Case)**：**$3N - 1$** 条消息。
        *   场景：**ID 最大的节点的逆时针邻居**（即它左手边的人）发起选举。
        *   推导：
            1.  邻居发出的 `Election` 消息走到最大 ID 节点：$N-1$ 跳。
            2.  最大 ID 节点收到后，发现自己更牛，把消息替换成自己的 ID，转一圈回到自己：$N$ 跳。
            3.  最大 ID 节点发 `Elected` 通知全员：$N$ 跳。
            4.  总计：$(N-1) + N + N = 3N - 1$。

#### 3. 同步系统中的共识 (Synchronous Consensus) —— **证明题核心**
*   **结论**：在同步系统中，如果有 $f$ 个节点故障，共识是可以解决的。
*   **算法**：运行 **$f+1$ 轮**。每一轮大家交换自己知道的所有信息。
*   **证明 (反证法)**：**为什么 $f+1$ 轮后大家的数据一定一致？**
    *   假设 $f+1$ 轮后，节点 $P_i$ 和 $P_j$ 的数据不一致（比如 $P_i$ 有值 $v$，而 $P_j$ 没有）。
    *   这意味着 $v$ 在第 $f+1$ 轮才传给 $P_i$（如果早传到了，$P_i$ 早就转给 $P_j$ 了）。
    *   这意味着在第 $f$ 轮，传给 $P_i$ 的那个节点挂了。
    *   以此类推，第 $f-1$ 轮也有节点挂了……
    *   推导结论：每一轮必须至少有一个节点挂掉，才能导致信息传递中断。
    *   那么 $f+1$ 轮就需要 **$f+1$ 个节点故障**。
    *   这与假设“最多 $f$ 个故障”矛盾。
    *   **证毕**。

---

### 第二部分：高频大题预测（计算与证明）

#### 【大题 1】环选举算法的消息复杂度分析（10分）
**题目描述：**
在一个由 5 个节点组成的环形分布式系统中，节点 ID 分别为 $\{10, 20, 50, 30, 40\}$，节点按顺时针排列（即 $10 \to 20 \to 50 \to 30 \to 40 \to 10$）。
系统使用 **Chang-Roberts 环选举算法**（即 PPT 中的算法）。

**问题：**
1.  **(3分)** 若节点 **50** 发现 Leader 挂了并由它发起选举，请计算产生的总消息数，并说明每一步的消息类型（Election/Elected）。
2.  **(3分)** 若节点 **20** 发起选举，请计算产生的总消息数，并详细描述 `Election` 消息的流转过程。
3.  **(4分)** 请推导该算法在 $N$ 个节点时的**最坏情况消息复杂度**公式，并解释其物理含义。

**【答案与解析】**
1.  **节点 50 发起 (最好情况)**：
    *   节点 50 是 ID 最大的节点。
    *   `Election(50)` 消息转一圈回到 50：**5 条**。
    *   节点 50 收到自己的 ID，确认当选，发送 `Elected(50)` 转一圈：**5 条**。
    *   总计：**10 条** (即 $2N$)。

2.  **节点 20 发起 (最坏情况)**：
    *   节点 20 是 ID 最大节点(50)的**逆时针邻居**（上游）。
    *   Step 1: 20 发送 `Election(20)`。
        *   $20 \to 50$：1 条。
    *   Step 2: 50 收到 `Election(20)`，发现 $50 > 20$，于是**吞掉**旧消息，发送新的 `Election(50)`。
        *   $50 \to 30 \to 40 \to 10 \to 20 \to 50$：转一圈回到 50，共 **5 条**。
    *   Step 3: 50 收到 `Election(50)`，当选，发送 `Elected(50)`。
        *   转一圈：**5 条**。
    *   总计：$1 + 5 + 5 = 11$ 条。
    *   *(注：对应公式 $3N-1 = 15-1 = 14$，这里因为 20 离 50 只有 1 跳，所以是 $1+5+5=11$。如果节点排列顺序导致 20 发出的消息要走 $N-1$ 步才遇到 50，那就是真正的最坏情况 14 条。考试时按具体步数数即可)*。

3.  **最坏情况推导**：
    *   场景：发起者是最大 ID 节点的上游邻居（逆时针方向第一个）。
    *   阶段 1：发起者发出的 `Election` 消息传输到最大 ID 节点，经过 $N-1$ 个节点，产生 **$N-1$** 条消息。
    *   阶段 2：最大 ID 节点截获消息，替换为自己的 ID，让 `Election(MaxID)` 绕环一周回到自己，产生 **$N$** 条消息。
    *   阶段 3：最大 ID 节点发送 `Elected` 消息通知全员，产生 **$N$** 条消息。
    *   总计：$(N-1) + N + N = 3N - 1$。

---

#### 【大题 2】同步系统共识与原子提交对比（10分）
**题目描述：**
1.  **(5分)** 在一个同步分布式系统中，假设最多可能有 $f$ 个节点发生崩溃故障（Crash-stop）。请简述如何通过“多轮信息交换”达成共识，并证明为什么 **$f+1$ 轮** 是足够的？
2.  **(5分)** 为什么说 **两阶段提交 (2PC)** 协议在协调者崩溃时是“阻塞”的？请对比 **共识算法 (如 Paxos/Raft)** 是如何解决这个阻塞问题的？

**【答案与解析】**
1.  **同步共识证明**：
    *   **算法**：所有节点在每一轮中广播自己已知的所有值，并将收到的新值加入自己的集合。运行 $f+1$ 轮。
    *   **证明**：使用反证法。
        *   假设 $f+1$ 轮后，节点之间仍未达成一致（即某个值 $v$ 被部分节点收到，部分没收到）。
        *   这意味着在第 $f+1$ 轮，传递值 $v$ 的节点崩溃了，导致 $v$ 没能传给所有人。
        *   这也意味着在第 $f$ 轮，传递值 $v$ 的节点也崩溃了（否则 $v$ 早就在第 $f$ 轮传开了）。
        *   以此类推，要导致 $f+1$ 轮后还不一致，必须**每一轮都有至少一个新的节点崩溃**。
        *   这意味总共有 $f+1$ 个节点崩溃，违反了“最多 $f$ 个故障”的假设。
        *   因此，在 $f+1$ 轮结束后，所有正常节点必然拥有相同的信息，达成共识。

2.  **2PC 阻塞 vs 共识**：
    *   **2PC 阻塞原因**：在 Phase 1，参与者回复 "Vote Commit" 后，就进入了**“犹豫状态”**。它必须等待协调者的最终指令。如果此时协调者崩溃（且没有其他节点知道决定），参与者**不敢提交**（怕协调者决定了回滚），也**不敢回滚**（怕协调者决定了提交）。所有持有锁的参与者只能无限等待，系统阻塞。
    *   **共识算法的解决**：共识算法（如 Paxos/Raft）基于**多数派 (Quorum)**。只要系统中**超过半数**的节点活着，就能选出新的 Leader，并在新的 Term 中继续达成一致，不会因为单个协调者（Leader）的崩溃而导致整个系统死锁。

---

### 第三部分：选择题精选（扫盲）

**1. 关于两阶段提交 (2PC) 和共识算法的区别，下列说法错误的是？**
A. 2PC 要求所有参与节点都必须健康才能成功提交
B. 共识算法只要有“法定多数 (Quorum)”节点健康即可工作
C. 2PC 是非阻塞的，而共识算法是阻塞的
D. 2PC 用于实现原子性 (Atomicity)，共识算法用于实现一致性 (Agreement)

**2. 在环选举算法中，节点 $P_i$ 收到一条 `Election(id: 50)` 的消息。如果 $P_i$ 自己的 ID 是 60，且 $P_i$ 尚未发起过选举，它会怎么做？**
A. 转发 `Election(id: 50)`
B. 丢弃该消息，不理会
C. 将消息中的 ID 改为 60，转发 `Election(id: 60)`
D. 宣布自己成为 Leader

**3. 在一个包含 $N$ 个节点的环选举算法中，消息复杂度的“最坏情况”是？**
A. $N$
B. $2N$
C. $3N - 1$
D. $N^2$

**4. 为什么 FLP 不可能性定理说“在异步系统中无法解决共识问题”？**
A. 因为异步系统无法区分“节点崩溃”和“网络极度延迟”
B. 因为异步系统中消息可能会丢失
C. 因为异步系统没有时钟
D. 因为拜占庭节点会撒谎

**5. 在同步系统中，如果系统最多容忍 $f$ 个节点崩溃，那么保证达成共识所需的最少轮数是？**
A. $f$
B. $f + 1$
C. $2f + 1$
D. $N/2$

---

### ✅ 答案
1.  **C** (2PC 是阻塞的，Coordinator 挂了就卡住了；共识是非阻塞的/容错的)。
2.  **C** (PPT P17 规则：如果收到的 ID < 自己的 ID，替换成自己的转发)。
3.  **C** (PPT P33 明确写了 $3N-1$)。
4.  **A** (PPT P51 提到 FLP 定理。核心是无法准确进行故障检测，导致算法可能永远无法终止)。
5.  **B** (PPT P48 证明结论，需要 $f+1$ 轮）。
---

**复习提示**：
*   **计算题**：一定要自己在纸上画一个圈，标上 ID，模拟一遍“小 ID 遇到大 ID 被吃掉，大 ID 遇到小 ID 替换掉”的过程。
*   **证明题**：记住“每一轮必须死一个”这个逻辑点。

## 第八章：最终一致性

---

### 第一部分：核心知识点摘要（重点：CAP & CRDT）

#### 1. CAP 定理 (CAP Theorem) —— **必考点**
*   **定义**：在一个分布式系统中，当发生**网络分区 (Partition)** 时，无法同时满足 **强一致性 (Consistency)** 和 **可用性 (Availability)**。
    *   **C (Consistency)**：**线性一致性 (Linearizability)**。所有节点看到的数据完全一致，像单机一样。
    *   **A (Availability)**：**可用性**。每个收到的非故障节点的请求都能得到响应（不报错，但不保证是最新数据）。
    *   **P (Partition Tolerance)**：**分区容错性**。系统在网络丢包或断开（分区）的情况下仍能运行。
*   **权衡 (Trade-off)**：
    *   **P 是客观存在的**（网络总会断），所以只能在 CP 和 AP 之间二选一。
    *   **CP 系统**：发生分区时，为了保数据一致，拒绝服务（牺牲 A）。例如：银行转账、分布式锁。
    *   **AP 系统**：发生分区时，为了保服务可用，返回旧数据（牺牲 C）。例如：朋友圈点赞、购物车。

#### 2. 强最终一致性 (Strong Eventual Consistency)
*   **两个条件**：
    1.  **最终送达**：只要没挂，更新最终会传给所有人。
    2.  **收敛 (Convergence)**：只要大家处理了**同一组更新**（不管顺序如何），最终状态**一定相同**。
*   **冲突解决**：
    *   **LWW (Last Writer Wins)**：看时间戳，晚的覆盖早的。缺点：**会丢失数据**。
    *   **多值寄存器**：保留所有冲突值，交给应用层解决。

#### 3. CRDT (无冲突复制数据类型) —— **选择题考点**
*   **核心思想**：设计一种特殊的数据结构，使得并发更新**不需要冲突解决**，自动合并。
*   **分类**：
    *   **基于状态 (State-based)**：发送整个状态。合并函数 $\sqcup$ 必须满足：**交换律、结合律、幂等性**。
    *   **基于操作 (Op-based)**：只发送操作（如 `add(x)`）。要求底层通信是**可靠的**（甚至是有序的）。
*   **例子**：
    *   **文本编辑**：Google Docs 使用类似技术。插入字符时使用唯一 ID 和相对位置，而不是绝对索引。

---

### 第二部分：模拟实战题库（针对性极强）

#### 🔴 CAP 专题（重点掌握）

**1. [概念辨析] 在 CAP 定理中，"C" 代表的一致性是指哪种一致性？**
A. 最终一致性 (Eventual Consistency)
B. 事务一致性 (ACID Consistency)
C. 线性一致性 (Linearizability)
D. 因果一致性 (Causal Consistency)

**2. [场景判断] 一个全球部署的电商网站的“购物车”功能。当跨国网络光缆中断（发生分区）时，为了保证用户体验，允许用户继续添加商品，即使不同地区的数据暂时不一致。这属于哪种系统设计？**
A. CA 系统
B. CP 系统
C. AP 系统
D. AC 系统

**3. [CAP 误区] 关于 CAP 定理，下列说法错误的是？**
A. 在没有发生网络分区（网络正常）的时候，系统可以同时满足一致性 (C) 和可用性 (A)
B. 既然无法同时满足 CAP，我们在设计系统时可以放弃 P（分区容错性）
C. 分布式系统必须能够容忍网络分区，因为网络故障是不可避免的
D. 选择 CP 意味着在网络分区期间，某些操作可能会超时或报错

---

#### 🔵 CRDT 与冲突解决（选择题特供）

**4. [CRDT 性质] 为了保证基于状态（State-based）的 CRDT 能够正确地合并来自不同节点的并发状态，其合并运算符（Merge Operator $\sqcup$）必须满足哪些数学性质？**
A. 必须满足原子性、隔离性、持久性
B. 必须满足**交换律 (Commutative)、结合律 (Associative)、幂等性 (Idempotent)**
C. 必须满足先入先出 (FIFO) 顺序
D. 必须依赖中心化的时钟同步

**5. [冲突解决] 很多 NoSQL 数据库（如 Cassandra）使用 "Last Writer Wins (LWW)" 策略来解决并发写入冲突。这种策略的主要缺点是？**
A. 实现非常复杂
B. 需要消耗大量的存储空间
C. **可能会导致并发写入的数据丢失**
D. 无法保证最终一致性

**6. [CRDT 类型] 关于基于操作（Operation-based）的 CRDT，下列说法正确的是？**
A. 它要求每次同步都发送整个数据对象的副本
B. 它对底层网络没有要求，允许消息丢失
C. 它通常要求底层的广播协议提供**可靠交付**（甚至因果有序交付），以确保操作不丢失、不重复
D. 它比基于状态的 CRDT 占用更多的网络带宽

---

### ✅ 答案与解析

1.  **C**。**考点：CAP 的 C**。CAP 的 C 指的是 Linearizability（强一致性/原子一致性），即所有节点看起来像一个节点。注意别选 B（ACID 的 C 是指业务规则不被破坏）。
2.  **C**。**考点：AP 选择**。网络断了（P 发生），为了体验允许继续用（保 A），牺牲数据一致（舍 C）。这是典型的 AP。
3.  **B**。**考点：P 不可丢**。在分布式系统中，网络分区是客观规律，不可避免，所以 P 是必须具备的，我们只能在 C 和 A 里选。
4.  **B**。**考点：CRDT 数学性质**。这是本章**最可能考**的一道 CRDT 选择题。记住“交换、结合、幂等”这三个词，意味着合并顺序无关紧要，且重复合并也没事。
5.  **C**。**考点：LWW 缺点**。LWW 简单粗暴，时间戳晚的直接覆盖早的。如果两个客户端同时修改不同字段，LWW 可能会丢掉其中一个人的修改。
6.  **C**。**考点：Op-based CRDT**。Op-based 只发操作指令（如 `+1`），如果指令丢了或发了两次（非幂等操作），结果就错了。所以依赖可靠广播。

---

**复习提示**：
*   **CAP**：死记硬背 **C=Linearizability**，**P=不可丢**，**AP=保可用弃一致**，**CP=保一致弃可用**。
*   **CRDT**：只记那三个数学性质（交换、结合、幂等）应付那一道选择题即可。

## 第九章：Hadoop 与 MapReduce

---

### 第一部分：核心知识点摘要（GFS/HDFS 大题专用）

#### 1. GFS/HDFS 的设计动机与特点（必背）
*   **硬件假设**：硬件出错是**常态**而非异常。系统运行在大量廉价、易损的机器上，必须通过软件层面保证可靠性。
*   **存储目标**：
    *   **大文件**：存储 GB/TB 级别的大文件（元数据少，减少 Master 压力）。
    *   **流式访问**：**一次写入，多次读取**（Write-once, Read-many）。
    *   **写模式**：主要是**追加写 (Append)**，极少随机修改。
*   **架构特点**：
    *   **中心服务器模式 (Master/Slave)**：
        *   **Master (NameNode)**：存元数据（文件名、目录、块位置），管理节点状态。**只有 1 个**。
        *   **ChunkServer (DataNode)**：存实际数据块（Linux 文件）。**有 N 个**。
    *   **控制流与数据流分离**（解决单点瓶颈的关键）：
        *   Client 只向 Master 问“数据在哪”（元数据）。
        *   Client **直接**与 ChunkServer 传输数据（数据流不经过 Master）。

#### 2. 数据块与副本策略
*   **块大小 (Block Size)**：**64MB**（比传统文件系统大得多）。
    *   *好处*：减少寻址开销；减少 Master 元数据数量；利于保持 TCP 长连接。
*   **副本放置策略 (机架感知 Rack Awareness)**：默认 3 副本。
    *   副本 1：本地节点（或随机）。
    *   副本 2：**不同机架**的随机节点（防机架断电/交换机故障）。
    *   副本 3：与副本 2 **同一机架**的不同节点（平衡可靠性与带宽）。

---

### 第二部分：高频大题预测

#### 【大题 1】GFS/HDFS 系统设计（10分）

**题目描述：**
GFS (Google File System) 是为大规模数据密集型应用设计的分布式文件系统。请回答以下问题：
1.  **(3分)** GFS 采用了 **单 Master (Single Master)** 的架构。请问这种架构有什么潜在的性能瓶颈？GFS 是通过什么机制来解决这个瓶颈的？
2.  **(3分)** GFS 将文件切分为 **64MB** 的大块 (Chunk)。相比于传统文件系统（如 KB 级别），这样设计的主要优点有哪些？（至少列举两点）
3.  **(4分)** 请简述 GFS/HDFS 的 **3 副本放置策略**，并解释为什么要跨机架存储。

**【答案与解析】**

1.  **瓶颈与解决**：
    *   **瓶颈**：Master 节点内存有限，且如果所有数据流量都经过 Master，它会成为**网络和 I/O 的瓶颈**。
    *   **解决**：实现了 **控制流与数据流分离**。客户端只与 Master 交互元数据（文件位置信息），实际的数据传输直接在客户端与 ChunkServer 之间进行，不经过 Master。

2.  **64MB 大块的优点**：
    *   **减少元数据**：块越大，块的数量越少，Master 需要维护的元数据就越少，可以全部放入内存。
    *   **减少寻址开销**：客户端可以与 ChunkServer 保持长时间的 TCP 连接进行大量数据传输，减少了频繁建立连接和寻址的时间。

3.  **3 副本策略**：
    *   **策略**：第 1 个副本在本地；第 2 个副本在**不同机架**的节点；第 3 个副本在**与第 2 个副本同机架**的另一个节点。
    *   **原因**：跨机架存储是为了**容错**。如果整个机架（包括交换机或电源）发生故障，位于不同机架的副本仍然可用，保证数据不丢失，提高可用性。

---

#### 【大题 2】MapReduce 代码填空（10分，Go 语言版）

**考点提示**：
PPT 里展示的是 Java 代码（Tokenizer, Context.write），但根据你的说明，考试用 **Go 语言**。
MapReduce 的逻辑是通用的：
*   **Map**: 输入 `(filename, content)` -> 输出 `list(word, "1")`
*   **Reduce**: 输入 `(word, list("1", "1", ...))` -> 输出 `(word, total_count)`

**题目模拟：**
请补充下列 Go 语言实现的 MapReduce WordCount 程序中的空缺代码。
`mapF` 函数需要将文本分割为单词，并输出中间键值对。
`reduceF` 函数需要统计每个单词出现的总次数。

```go
package main

import (
	"strconv"
	"strings"
	"unicode"
)

// KeyValue 是 Map 函数返回的结构体
type KeyValue struct {
	Key   string
	Value string
}

// 1. Map 函数
// 参数: filename (文件名), contents (文件内容)
// 返回: 一个 KeyValue 切片
func mapF(filename string, contents string) []KeyValue {
	// 用于分割单词的辅助函数，非字母字符视为分隔符
	ff := func(r rune) bool { return !unicode.IsLetter(r) }

	// 将内容分割成单词数组
	words := strings.FieldsFunc(contents, ff)

	var kva []KeyValue

	// 【问题 1：请补全 Map 逻辑，遍历单词并生成中间键值对】(5分)
	for _, w := range words {
		// ---------------- 填空区域开始 ----------------
		
        // 提示：生成的 Key 是单词 w，Value 是字符串 "1"
        kv := KeyValue{Key: w, Value: "1"}
        kva = append(kva, kv)

		// ---------------- 填空区域结束 ----------------
	}
	return kva
}

// 2. Reduce 函数
// 参数: key (单词), values (该单词对应的一组计数值，如 ["1", "1", "1"])
// 返回: 统计后的总次数，作为字符串
func reduceF(key string, values []string) string {
	// 【问题 2：请补全 Reduce 逻辑，统计单词总数】(5分)
	
    // ---------------- 填空区域开始 ----------------
    sum := 0
    for _, v := range values {
        // 将字符串转换为数字
        count, _ := strconv.Atoi(v) 
        sum += count
    }
    // 将总数转换回字符串返回
    return strconv.Itoa(sum)
    // ---------------- 填空区域结束 ----------------
}
```

**【解析】**
*   **Map 部分**：逻辑非常简单，就是遍历 `words` 数组，对每个单词，生成一个 `{Key: w, Value: "1"}` 的对象，并添加到结果切片 `kva` 中。这对应 PPT 中 `context.write(word, one)` 的逻辑。
*   **Reduce 部分**：输入是 `values` 数组（例如 `["1", "1", "1"]`）。逻辑是遍历数组，把字符串转成 `int`，累加到 `sum`，最后把 `sum` 转回 `string` 返回。这对应 PPT 中 `sum += val; context.write(key, sum)` 的逻辑。

---

### 第三部分：选择题精选（查漏补缺）

**1. GFS/HDFS 选用 64MB（或更大）作为数据块（Chunk/Block）大小的主要原因**不包括**下列哪项？**
A. 减少 NameNode (Master) 的元数据内存占用
B. 减少客户端与服务器交互的寻址开销
C. 提高小文件的随机读写性能
D. 充分利用网络带宽进行流式传输

**2. 在 MapReduce 的执行流程中，Map 阶段和 Reduce 阶段中间有一个重要的过程，负责将 Map 输出的数据按 Key 进行排序、合并并传输给 Reduce 节点，这个过程叫做？**
A. Combine
B. Shuffle
C. Partition
D. Scheduling

**3. 在 HDFS 中，NameNode (Master) 负责管理什么？**
A. 文件的具体数据内容
B. 文件的元数据（文件名、目录结构、块位置映射）
C. 客户端的数据传输流
D. 实际的数据计算任务

**4. MapReduce 编程模型非常适合处理哪种类型的任务？**
A. 相互依赖性强、需要频繁通信的复杂计算任务
B. 实时性要求极高的小数据量查询任务
C. 海量数据的批处理任务（如日志分析、倒排索引构建）
D. 递归深度很大的图算法

---

### ✅ 答案
1.  **C** (大块对小文件随机读写非常不友好，容易造成空间浪费和碎片，这是 GFS 的弱点)。
2.  **B** (Shuffle 是 MapReduce 的灵魂，PPT P43 提到 Shuffle 和 Sort)。
3.  **B** (NameNode 存元数据，DataNode 存数据)。
4.  **C** (PPT P28 提到 Motivation 是几百 TB 数据的分析，Motivation 是流式读写)。

---

**复习提示**：
*   **代码填空**：如果你对 Go 语言不熟，重点记 `kv := KeyValue{Key: w, Value: "1"}` 和 `strconv.Atoi(v)` / `strconv.Itoa(sum)` 这几个转换函数。逻辑就是“Map 拆分标 1，Reduce 汇总求和”。
*   **GFS**：一定要记住 **Master 存元数据**，**Client 直连 ChunkServer**，这是最高频的考点。

## 第十章：云计算模型

---

### 第一部分：核心知识点摘要（大题必背）

#### 1. 三种服务模型 (SPI) —— **重点中的重点**
PPT 中使用了“盖房子、买公寓、住酒店”的类比，非常形象，考试时可以用作辅助理解。

*   **IaaS (Infrastructure as a Service，基础设施即服务)**：
    *   **定义**：提供底层的计算、存储、网络资源（虚拟机、裸操作系统）。
    *   **类比**：**盖房子/租毛坯房**。给你地皮和砖头（CPU/内存/磁盘），你自己装修（装OS）、买家具（装软件）。
    *   **用户**：系统管理员、运维人员。
    *   **例子**：**AWS EC2**, 阿里云 ECS。
    *   **责任**：厂商管硬件和虚拟化；用户管OS、应用、数据。

*   **PaaS (Platform as a Service，平台即服务)**：
    *   **定义**：提供软件开发和运行环境（编程接口、库、中间件）。
    *   **类比**：**买精装公寓**。房子装修好了（OS和环境都有了），你直接拎包入住（部署代码），不能拆承重墙（不能改底层OS）。
    *   **用户**：**开发人员 (Developers)**。
    *   **例子**：**Google App Engine (GAE)**, Microsoft Azure (早期)。
    *   **责任**：厂商管OS和运行环境；用户管代码和数据。

*   **SaaS (Software as a Service，软件即服务)**：
    *   **定义**：直接提供可用的应用程序。
    *   **类比**：**住酒店**。什么都不用管，直接享受服务。
    *   **用户**：**终端用户 (End Users)**。
    *   **例子**：**Gmail**, Google Docs, Salesforce, 百度网盘, 微信。
    *   **责任**：厂商管一切；用户只管用。

#### 2. 四种部署模型
*   **公有云 (Public Cloud)**：
    *   资源由服务商拥有，面向公众开放。
    *   特点：**同构资源、多租户共享、规模经济（便宜）**。
*   **私有云 (Private Cloud)**：
    *   资源供**单个组织**专用。
    *   特点：**安全、可控、异构资源**，但成本高。
*   **混合云 (Hybrid Cloud)**：
    *   **公有云 + 私有云**。
    *   场景：核心敏感数据放私有云，非敏感或突发流量业务放公有云（Cloud Bursting）。
*   **社区云 (Community Cloud)**：
    *   由具有共同诉求（如安全性、合规性）的特定社区共享。

#### 3. 云计算五大特征 (NIST) —— **简答题备选**
1.  **按需自服务 (On-demand self-service)**：无需人工干预，想要多少点多少。
2.  **泛在网络访问 (Broad network access)**：通过互联网随时随地接入。
3.  **资源池化 (Resource pooling)**：多租户共享资源，位置无关。
4.  **快速弹性 (Rapid elasticity)**：像弹簧一样，业务量大就扩容，小就缩容。
5.  **服务可计量 (Measured service)**：像水电表一样计费 (Pay-as-you-go)。

---

### 第二部分：高频大题预测（场景分析与辨析）

#### 【大题 5】云计算服务与部署模型（10分）

**题目描述：**
某大型互联网公司计划开发并部署一套全新的企业级应用系统。该系统包含由于法律法规要求必须高度保密的**核心财务数据**，以及面向全球数亿普通用户的**Web 前端服务**。
请结合云计算的相关知识，回答以下问题：

1.  **(4分)** 该公司决定采用 **混合云 (Hybrid Cloud)** 的部署策略。请具体说明针对“核心财务数据”和“Web 前端服务”应分别部署在什么类型的云上？并简述理由。
2.  **(6分)** 在开发过程中，不同的团队对云资源的需求不同。请判断以下三个场景分别属于 **IaaS、PaaS 还是 SaaS** 服务模型？（每项 2 分）
    *   **场景 A**：运维团队需要租赁 100 台 Linux 虚拟机，并在上面自行安装配置特殊的数据库软件和防火墙策略。
    *   **场景 B**：开发团队希望专注于编写 Java 代码，不想关心底层的操作系统补丁和负载均衡配置，直接将代码上传即可运行。
    *   **场景 C**：公司的人力资源部门直接购买并使用一套在线的 HR 管理系统来处理员工考勤，无需任何开发和维护。

**【答案与解析】**

1.  **部署策略与理由**：
    *   **核心财务数据**应部署在 **私有云 (Private Cloud)**。
        *   *理由*：私有云提供最高的**安全性**和**数据控制权**，符合法律法规对敏感数据的合规性要求。
    *   **Web 前端服务**应部署在 **公有云 (Public Cloud)**。
        *   *理由*：Web 服务面向全球用户，流量波动大。公有云提供**海量资源**和**快速弹性 (Rapid elasticity)**，能应对突发流量，且利用规模经济降低成本。

2.  **服务模型判断**：
    *   **场景 A (IaaS)**：
        *   *解析*：租赁的是虚拟机 (VM) 等**基础设施**，用户需要自己管理操作系统和中间件。这是典型的 **Infrastructure as a Service**。
    *   **场景 B (PaaS)**：
        *   *解析*：开发人员只负责代码，运行环境（OS、中间件）由平台提供。这是典型的 **Platform as a Service**。
    *   **场景 C (SaaS)**：
        *   *解析*：直接使用成品的软件服务，无需开发和运维。这是典型的 **Software as a Service**。

---

### 第三部分：选择题精选（概念巩固）

**1. 根据 NIST 的定义，下列哪项**不是**云计算的五大基本特征之一？**
A. 按需自服务 (On-demand self-service)
B. 资源池化 (Resource pooling)
C. 快速弹性 (Rapid elasticity)
D. 专用硬件 (Dedicated Hardware)

**2. 像 Google Docs、Gmail 或 微信 这类应用，对于终端用户来说，属于哪种云计算服务模型？**
A. IaaS
B. PaaS
C. SaaS
D. DaaS

**3. 某初创公司想要开发一款 APP，他们不想花费精力维护服务器硬件和操作系统，只想专注于业务代码的编写。他们应该选择哪种云服务模型？**
A. IaaS
B. PaaS
C. SaaS
D. 私有云

**4. 关于“混合云 (Hybrid Cloud)”，下列说法正确的是？**
A. 它是由多个公有云组成的
B. 它是指同时使用 IaaS 和 PaaS
C. 它是公有云和私有云的结合，通过技术实现数据和应用的移植性
D. 它是一种免费的云服务

**5. 在 IaaS（基础设施即服务）模型中，云服务提供商（Provider）通常负责管理哪一层？**
A. 应用程序 (Application)
B. 数据 (Data)
C. 操作系统 (Runtime/OS)
D. 虚拟化层与物理硬件 (Virtualization & Hardware)

---

### ✅ 答案
1.  **D** (云计算强调资源共享/池化，而非专用硬件)。
2.  **C** (直接用的软件，SaaS)。
3.  **B** (专注代码，不管OS，选 PaaS。如果选 IaaS 还得配环境)。
4.  **C** (定义：公有+私有)。
5.  **D** (PPT P28 架构图，IaaS 厂商管到虚拟化层，OS 往上归用户管)。

---

